Free variable print_int assumed as external
[Typing.f]
(let rec ( (ack:(int->int->int)) (x:int) (y:int) = (if (x <= 0) then (y + 1) else (if (y <= 0) then (ack (x - 1) 1) else (ack (x - 1) (ack x (y - 1))))) in (print_int (ack 3 10)))

[KNormal.f]
[1:1 - 5:21] let rec (ack:(int->int->int)) (x:int) (y:int) =
  [2:3 - 4:30] let Ti4:int = [2:11-12] 0 in
  [2:3 - 4:30] if x <= Ti4 then
    [2:18-23] let Ti5:int = [2:22-23] 1 in
    [2:18-23] y + Ti5
  else 
    [3:3 - 4:30] let Ti6:int = [3:11-12] 0 in
    [3:3 - 4:30] if y <= Ti6 then
      [3:18-31] let Ti8:int =
        [3:22-29] let Ti7:int = [3:27-28] 1 in
        [3:22-29] x - Ti7 in
      [3:18-31] let Ti9:int = [3:30-31] 1 in
      [3:18-31] ack Ti8 Ti9
    else 
      [4:3-30] let Ti11:int =
        [4:7-14] let Ti10:int = [4:12-13] 1 in
        [4:7-14] x - Ti10 in
      [4:3-30] let Ti14:int =
        [4:15-30] let Ti13:int =
          [4:22-29] let Ti12:int = [4:27-28] 1 in
          [4:22-29] y - Ti12 in
        [4:15-30] ack x Ti13 in
      [4:3-30] ack Ti11 Ti14 in
[5:1-21] let Ti3:int =
  [5:11-21] let Ti1:int = [5:16-17] 3 in
  [5:11-21] let Ti2:int = [5:18-20] 10 in
  [5:11-21] ack Ti1 Ti2 in
[5:1-21] *print_int* Ti3

[Alpha.f]
[1:1 - 5:21] let rec (ack.15:(int->int->int)) (x.16:int) (y.17:int) =
  [2:3 - 4:30] let Ti4.21:int = [2:11-12] 0 in
  [2:3 - 4:30] if x.16 <= Ti4.21 then
    [2:18-23] let Ti5.31:int = [2:22-23] 1 in
    [2:18-23] y.17 + Ti5.31
  else 
    [3:3 - 4:30] let Ti6.22:int = [3:11-12] 0 in
    [3:3 - 4:30] if y.17 <= Ti6.22 then
      [3:18-31] let Ti8.28:int =
        [3:22-29] let Ti7.30:int = [3:27-28] 1 in
        [3:22-29] x.16 - Ti7.30 in
      [3:18-31] let Ti9.29:int = [3:30-31] 1 in
      [3:18-31] ack.15 Ti8.28 Ti9.29
    else 
      [4:3-30] let Ti11.23:int =
        [4:7-14] let Ti10.27:int = [4:12-13] 1 in
        [4:7-14] x.16 - Ti10.27 in
      [4:3-30] let Ti14.24:int =
        [4:15-30] let Ti13.25:int =
          [4:22-29] let Ti12.26:int = [4:27-28] 1 in
          [4:22-29] y.17 - Ti12.26 in
        [4:15-30] ack.15 x.16 Ti13.25 in
      [4:3-30] ack.15 Ti11.23 Ti14.24 in
[5:1-21] let Ti3.18:int =
  [5:11-21] let Ti1.19:int = [5:16-17] 3 in
  [5:11-21] let Ti2.20:int = [5:18-20] 10 in
  [5:11-21] ack.15 Ti1.19 Ti2.20 in
[5:1-21] *print_int* Ti3.18

[Iteration 1000]
[1:1 - 5:21] let rec (ack.15:(int->int->int)) (x.16:int) (y.17:int) =
  [2:3 - 4:30] let Ti4.21:int = [2:11-12] 0 in
  [2:3 - 4:30] if x.16 <= Ti4.21 then
    [2:18-23] let Ti5.31:int = [2:22-23] 1 in
    [2:18-23] y.17 + Ti5.31
  else 
    [3:3 - 4:30] let Ti6.22:int = [3:11-12] 0 in
    [3:3 - 4:30] if y.17 <= Ti6.22 then
      [3:18-31] let Ti7.30:int = [3:27-28] 1 in
      [3:18-31] let Ti8.28:int = [3:22-29] x.16 - Ti7.30 in
      [3:18-31] let Ti9.29:int = [3:30-31] 1 in
      [3:18-31] ack.15 Ti8.28 Ti9.29
    else 
      [4:3-30] let Ti10.27:int = [4:12-13] 1 in
      [4:3-30] let Ti11.23:int = [4:7-14] x.16 - Ti10.27 in
      [4:3-30] let Ti12.26:int = [4:27-28] 1 in
      [4:3-30] let Ti13.25:int = [4:22-29] y.17 - Ti12.26 in
      [4:3-30] let Ti14.24:int = [4:15-30] ack.15 x.16 Ti13.25 in
      [4:3-30] ack.15 Ti11.23 Ti14.24 in
[5:1-21] let Ti1.19:int = [5:16-17] 3 in
[5:1-21] let Ti2.20:int = [5:18-20] 10 in
[5:1-21] let Ti3.18:int = [5:11-21] ack.15 Ti1.19 Ti2.20 in
[5:1-21] *print_int* Ti3.18

[Iteration 999]
[1:1 - 5:21] let rec (ack.15:(int->int->int)) (x.16:int) (y.17:int) =
  [2:3 - 4:30] let Ti4.21:int = [2:11-12] 0 in
  [2:3 - 4:30] if x.16 <= Ti4.21 then
    [2:18-23] let Ti5.31:int = [2:22-23] 1 in
    [2:18-23] y.17 + Ti5.31
  else 
    [3:3 - 4:30] let Ti6.22:int = [3:11-12] 0 in
    [3:3 - 4:30] if y.17 <= Ti6.22 then
      [3:18-31] let Ti7.30:int = [3:27-28] 1 in
      [3:18-31] let Ti8.28:int = [3:22-29] x.16 - Ti7.30 in
      [3:18-31] let Ti9.29:int = [3:30-31] 1 in
      [3:18-31] ack.15 Ti8.28 Ti9.29
    else 
      [4:3-30] let Ti10.27:int = [4:12-13] 1 in
      [4:3-30] let Ti11.23:int = [4:7-14] x.16 - Ti10.27 in
      [4:3-30] let Ti12.26:int = [4:27-28] 1 in
      [4:3-30] let Ti13.25:int = [4:22-29] y.17 - Ti12.26 in
      [4:3-30] let Ti14.24:int = [4:15-30] ack.15 x.16 Ti13.25 in
      [4:3-30] ack.15 Ti11.23 Ti14.24 in
[5:1-21] let Ti1.19:int = [5:16-17] 3 in
[5:1-21] let Ti2.20:int = [5:18-20] 10 in
[5:1-21] let Ti3.18:int = [5:11-21] ack.15 Ti1.19 Ti2.20 in
[5:1-21] *print_int* Ti3.18

Directly applying ack.15
Directly applying ack.15
Directly applying ack.15
Directly applying ack.15
Eliminating closure(s) ack.15
[Closure.f]
let_fun (*ack.15*:(int->int->int)) (x.16:int) (y.17:int) =
  [2:3 - 4:30] let Ti4.21:int = [2:11-12] 0 in
  [2:3 - 4:30] if x.16 <= Ti4.21 then
    [2:18-23] let Ti5.31:int = [2:22-23] 1 in
    [2:18-23] y.17 + Ti5.31
  else 
    [3:3 - 4:30] let Ti6.22:int = [3:11-12] 0 in
    [3:3 - 4:30] if y.17 <= Ti6.22 then
      [3:18-31] let Ti7.30:int = [3:27-28] 1 in
      [3:18-31] let Ti8.28:int = [3:22-29] x.16 - Ti7.30 in
      [3:18-31] let Ti9.29:int = [3:30-31] 1 in
      [3:18-31] *ack.15* Ti8.28 Ti9.29
    else 
      [4:3-30] let Ti10.27:int = [4:12-13] 1 in
      [4:3-30] let Ti11.23:int = [4:7-14] x.16 - Ti10.27 in
      [4:3-30] let Ti12.26:int = [4:27-28] 1 in
      [4:3-30] let Ti13.25:int = [4:22-29] y.17 - Ti12.26 in
      [4:3-30] let Ti14.24:int = [4:15-30] *ack.15* x.16 Ti13.25 in
      [4:3-30] *ack.15* Ti11.23 Ti14.24 in
[5:1-21] let Ti1.19:int = [5:16-17] 3 in
[5:1-21] let Ti2.20:int = [5:18-20] 10 in
[5:1-21] let Ti3.18:int = [5:11-21] *ack.15* Ti1.19 Ti2.20 in
[5:1-21] *min_caml_print_int* Ti3.18

[Virtual.f]
let_fun *ack.15* int(x.16, y.17) float() =
  [2:3 - 4:30] let Ti4.21:int = li 0 in
  [2:3 - 4:30] if le x.16 Ti4.21 then
    [2:18-23] let Ti5.31:int = li 1 in
  [2:18-23] add y.17 Ti5.31
  else
    [3:3 - 4:30] let Ti6.22:int = li 0 in
    [3:3 - 4:30] if le y.17 Ti6.22 then
      [3:18-31] let Ti7.30:int = li 1 in
    [3:18-31] let Ti8.28:int = sub x.16 Ti7.30 in
    [3:18-31] let Ti9.29:int = li 1 in
    [3:18-31] call *ack.15* int(Ti8.28, Ti9.29) float()
    else
      [4:3-30] let Ti10.27:int = li 1 in
      [4:3-30] let Ti11.23:int = sub x.16 Ti10.27 in
      [4:3-30] let Ti12.26:int = li 1 in
      [4:3-30] let Ti13.25:int = sub y.17 Ti12.26 in
      [4:3-30] let Ti14.24:int = call *ack.15* int(x.16, Ti13.25) float() in
      [4:3-30] call *ack.15* int(Ti11.23, Ti14.24) float()
  :int in
[5:1-21] let Ti1.19:int = li 3 in
[5:1-21] let Ti2.20:int = li 10 in
[5:1-21] let Ti3.18:int = call *ack.15* int(Ti1.19, Ti2.20) float() in
[5:1-21] call *min_caml_print_int* int(Ti3.18) float()

[Simm.f]
let_fun *ack.15* int(x.16, y.17) float() =
  [2:3 - 4:30] if le x.16 0 then
    [2:18-23] add y.17 1
  else
    [3:3 - 4:30] if le y.17 0 then
      [3:18-31] let Ti8.28:int = sub x.16 1 in
    [3:30-31] let Ti9.29:int = li 1 in
    [3:18-31] call *ack.15* int(Ti8.28, Ti9.29) float()
    else
      [4:3-30] let Ti11.23:int = sub x.16 1 in
      [4:3-30] let Ti13.25:int = sub y.17 1 in
      [4:3-30] let Ti14.24:int = call *ack.15* int(x.16, Ti13.25) float() in
      [4:3-30] call *ack.15* int(Ti11.23, Ti14.24) float()
  :int in
[5:16-17] let Ti1.19:int = li 3 in
[5:18-20] let Ti2.20:int = li 10 in
[5:1-21] let Ti3.18:int = call *ack.15* int(Ti1.19, Ti2.20) float() in
[5:1-21] call *min_caml_print_int* int(Ti3.18) float()

Register allocation: may take some time (up to a few minutes, depending on the size of functions)
Generating assembly...
